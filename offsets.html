<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Offsets - Glacier</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="loading">
    <div class="spinner"></div>
  </div>

  <div class="maintenance-overlay" id="maintenanceOverlay" style="display: none;">
    <div class="maintenance-content">
      <h1 class="maintenance-title">❄️ Under Maintenance</h1>
      <p class="maintenance-text">We're currently performing scheduled maintenance.<br>Check back later!</p>
      <button class="glossy-button" onclick="location.reload()">Refresh Site</button>
    </div>
  </div>

  <nav class="navbar">
    <div class="nav-logo"><span>Glacier</span></div>
    <div class="nav-links">
      <a href="index.html" class="nav-link">Home</a>
      <a href="download.html" class="nav-link">Download</a>
      <a href="offsets.html" class="nav-link active">Offsets</a>
      <a href="team.html" class="nav-link">Team</a>
    </div>
  </nav>

  <div class="dark-overlay"></div>
  
  <div class="snowflakes">
    <div class="snowflake">❅</div>
    <div class="snowflake">❆</div>
    <div class="snowflake">❅</div>
    <div class="snowflake">❆</div>
    <div class="snowflake">❅</div>
    <div class="snowflake">❆</div>
    <div class="snowflake">❅</div>
    <div class="snowflake">❆</div>
    <div class="snowflake">❅</div>
    <div class="snowflake">❆</div>
    <div class="snowflake">❅</div>
    <div class="snowflake">❆</div>
  </div>

  <div class="particles">
    <div class="particle"></div><div class="particle"></div><div class="particle"></div>
    <div class="particle"></div><div class="particle"></div><div class="particle"></div>
    <div class="particle"></div><div class="particle"></div>
  </div>

  <div class="page active">
    <div class="container offsets-container">
      <p></p>
      <p></p>
      <p></p>
      <h1 class="title">Offsets</h1>
      <p class="subtitle">Current Roblox offsets and version information</p>

      <div class="main-content">
        <div class="platform-selector">
          <button class="platform-btn active" data-platform="windows">Windows</button>
          <button class="platform-btn" data-platform="mac">Mac</button>
        </div>

        <div class="version-display">
          <h2 class="changelog-title">Current Roblox Version</h2>
          <div class="version-box" id="versionBox">
            <div class="version-status" id="versionStatus">Loading...</div>
            <div class="version-text" id="versionText">...</div>
          </div>
          <p class="last-checked">Last checked: <span id="lastChecked">Never</span></p>
        </div>

        <div class="offsets-section">
          <h2 class="changelog-title" id="offsetsTitle">Windows Offsets</h2>
          <div class="offsets-box" id="offsetsBox">
            <pre id="offsetsContent">Loading offsets...</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="notification">
    <div class="notification-title">All Systems Operational</div>
    <div class="notification-text">Everything running smoothly!</div>
  </div>

  <script>
    const FLASH_DURATION_MS = 3600000;

    const PLATFORM_CONFIG = {
      windows: {
        versionUrl: 'https://raw.githubusercontent.com/g4bigtjs/myportfolio/main/versions/windows.txt',
        offsetsPath: 'offsets/windows-offsets.txt',
        updateTrackerPath: 'offsets/last-update.txt',
        versionKey: 'Windows',
        title: 'Windows Offsets'
      },
      mac: {
        versionUrl: 'https://raw.githubusercontent.com/g4bigtjs/myportfolio/main/versions/mac.txt',
        offsetsPath: 'offsets/mac-offsets.txt',
        updateTrackerPath: 'offsets/last-update-mac.txt',
        versionKey: 'Mac',
        title: 'Mac Offsets'
      }
    };

    let currentPlatform = 'windows';
    let cachedVersionData = null;

    function setStatus(status, version, box, statusEl, textEl) {
      textEl.textContent = version;
      box.className = `version-box ${status}`;
      statusEl.textContent =
        status === 'updated' ? 'Recently Updated' :
        status === 'current' ? 'Current Version' :
        'Error';
    }

    async function fetchVersionForPlatform(platform) {
      const config = PLATFORM_CONFIG[platform];
      
      try {
        const response = await fetch(config.versionUrl + '?t=' + Date.now());
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const version = await response.text();
        return version.trim();
      } catch (e) {
        console.error(`Failed to fetch ${platform} version:`, e);
        return null;
      }
    }

    async function fetchVersionData() {
      try {
        const windowsVersion = await fetchVersionForPlatform('windows');
        const macVersion = await fetchVersionForPlatform('mac');
        
        cachedVersionData = {
          Windows: windowsVersion,
          Mac: macVersion
        };
        return cachedVersionData;
      } catch (e) {
        console.error('Failed to fetch version data:', e);
        return null;
      }
    }

    async function fetchRobloxVersion() {
      const config = PLATFORM_CONFIG[currentPlatform];
      const box = document.getElementById('versionBox');
      const statusEl = document.getElementById('versionStatus');
      const textEl = document.getElementById('versionText');
      const lastChecked = document.getElementById('lastChecked');
      lastChecked.textContent = new Date().toLocaleString();

      try {
        const versionData = await fetchVersionData();
        if (!versionData || !versionData[config.versionKey]) {
          throw new Error('API failed');
        }

        const currentVersion = versionData[config.versionKey];

        let globalUpdateTime = 0;
        let globalVersion = null;
        try {
          const trackerRes = await fetch(config.updateTrackerPath + '?t=' + Date.now());
          if (trackerRes.ok) {
            const text = await trackerRes.text();
            if (text.trim()) {
              // Format: timestamp|version (e.g., "1731513600000|version-xxx")
              const parts = text.trim().split('|');
              globalUpdateTime = parseInt(parts[0]) || 0;
              globalVersion = parts[1] || null;
            }
          }
        } catch (e) {
          console.warn('Could not fetch or parse global update tracker:', e);
        }

        let status = 'current';
        const elapsed = Date.now() - globalUpdateTime;

        if (elapsed < FLASH_DURATION_MS && globalUpdateTime > 0) {
          status = 'updated';
        }

        setStatus(status, currentVersion, box, statusEl, textEl);

        if (status === 'updated') {
          const remainingTime = FLASH_DURATION_MS - elapsed;
          if (remainingTime > 0) {
            setTimeout(() => setStatus('current', currentVersion, box, statusEl, textEl), remainingTime);
          }
        }
      } catch (e) {
        setStatus('error', 'Failed to load', box, statusEl, textEl);
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function highlightCppSyntax(text) {
      let res = escapeHtml(text);
      res = res.replace(/\b(0x[0-9A-Fa-f]+)\b/g, '<span class="syntax-hex">$1</span>');
      res = res.replace(/\b(namespace|inline|constexpr)\b/g, '<span class="syntax-keyword">$1</span>');
      res = res.replace(/\b(uintptr_t)\b/g, '<span class="syntax-type">$1</span>');
      res = res.replace(/\b([A-Z][a-zA-Z0-9_]*)\b(\s*=)/g, '<span class="syntax-identifier">$1</span>$2');
      res = res.replace(/([{}])/g, '<span class="syntax-brace">$1</span>');
      return res;
    }

    async function loadOffsets() {
      const config = PLATFORM_CONFIG[currentPlatform];
      const offsetsContent = document.getElementById('offsetsContent');
      
      try {
        // Get version from cached data or fetch new
        const versionData = cachedVersionData || await fetchVersionData();
        if (!versionData || !versionData[config.versionKey]) {
          throw new Error('Failed to get version');
        }

        const version = versionData[config.versionKey];
        
        // Fetch offsets from local TXT file
        const response = await fetch(config.offsetsPath + '?t=' + Date.now());
        if (!response.ok) throw new Error('Failed to fetch offsets file');
        
        const text = await response.text();
        if (!text.trim()) throw new Error('Empty offsets file');
        
        // Parse the TXT format: each line is "NAME=0xVALUE"
        const lines = text.trim().split('\n');
        const offsets = {};
        
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
          
          const [name, value] = trimmed.split('=').map(s => s.trim());
          if (name && value) {
            offsets[name] = value;
          }
        }
        
        if (Object.keys(offsets).length === 0) {
          throw new Error('No offsets found in file');
        }

        // Format offsets as C++ code
        let offsetsText = `namespace offsets {\n`;
        for (const [key, value] of Object.entries(offsets)) {
          offsetsText += `    constexpr uintptr_t ${key} = ${value};\n`;
        }
        offsetsText += `}`;

        offsetsContent.innerHTML = highlightCppSyntax(offsetsText);
      } catch (e) {
        offsetsContent.innerHTML =
          `<span style="color:#ff6b6b;">Error loading offsets: ${e.message}</span>`;
      }
    }

    function switchPlatform(platform) {
      currentPlatform = platform;
      const config = PLATFORM_CONFIG[platform];

      document.querySelectorAll('.platform-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.platform === platform);
      });

      document.getElementById('offsetsTitle').textContent = config.title;

      loadOffsets();
      fetchRobloxVersion();
    }

    async function checkMaintenance() {
      try {
        const response = await fetch('maintenance.txt?t=' + Date.now());
        const text = await response.text();
        const isMaintenance = text.trim().toLowerCase() === 'true';
        
        if (isMaintenance) {
          document.getElementById('maintenanceOverlay').style.display = 'flex';
        }
      } catch (error) {
        console.error('Failed to check maintenance status');
      }
    }

    window.addEventListener('load', () => {
      const loading = document.querySelector('.loading');
      loading.style.animation = 'fadeOut 1s ease 0.5s forwards';
      setTimeout(() => (loading.style.display = 'none'), 1500);

      checkMaintenance();
    });

    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.platform-btn').forEach(btn => {
        btn.addEventListener('click', () => switchPlatform(btn.dataset.platform));
      });

      loadOffsets();
      fetchRobloxVersion();
      setInterval(fetchRobloxVersion, 60000);
      setInterval(loadOffsets, 300000);
    });
  </script>
</body>
</html>
